// backend/services/staffService.js
const { pool } = require('../database');

/**
 * Get all staff members from the database
 * @returns {Promise<Array>} Array of staff objects
 */
const getAllStaff = async () => {
  const res = await pool.query('SELECT * FROM staff');
  return res.rows;
};

/**
 * Get a single staff member by ID
 * @param {string} id - Staff ID (e.g., 'S1', 'S2')
 * @returns {Promise<Object>} Staff object
 */
const getStaffById = async (id) => {
  try {
    const result = await pool.query('SELECT * FROM staff WHERE id = $1', [id]);
    return result.rows[0] || null;
  } catch (err) {
    console.error(`Error fetching staff ${id}:`, err.message);
    throw err;
  }
};

/**
 * Create a new staff member
 * @param {Object} staffData - Staff data
 * @returns {Promise<Object>} Created staff object
 */
const createStaff = async (staffData) => {
  // Validate required fields (id is auto-generated by DB)
  if (!staffData.first_name || !staffData.last_name) {
    throw new Error('Missing required staff data: first_name and last_name are required');
  }

  try {
    const {
      first_name,
      last_name,
      address = null,
      suburb = null,
      state = 'NSW',
      postcode = null,
      // allow either modern `phone` or legacy `contact_phone`
      phone = staffData.phone ?? staffData.contact_phone ?? null,
      // allow either modern `email` or legacy `contact_email`
      email = staffData.email ?? staffData.contact_email ?? null,
      // optional additional columns that actually exist
      position = staffData.position ?? staffData.role ?? null,
      // --- NEW financial fields ---
      contracted_hours = staffData.contracted_hours ?? null,
      // allow a few legacy aliases for pay rate coming from CSV / UI
      base_pay_rate =
        staffData.base_pay_rate ??
        staffData.pay_rate ??          // alias
        staffData.hourly_rate ??       // alias
        null,
      // staff status flags
      active = staffData.active ?? true
    } = staffData;

    const result = await pool.query(
      `INSERT INTO staff 
       (first_name, last_name, address, suburb, state, postcode,
        phone, email,
        position,
        contracted_hours, base_pay_rate,
        active)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
       RETURNING *`,
      [
        first_name,
        last_name,
        address,
        suburb,
        state,
        postcode,
        phone,
        email,
        position,
        contracted_hours,
        base_pay_rate,
        active
      ]
    );
    return result.rows[0];
  } catch (err) {
    console.error('Error creating staff:', err.message);
    throw err;
  }
};

/**
 * Update an existing staff member
 * @param {string} id - Staff ID
 * @param {Object} staffData - Updated staff data
 * @returns {Promise<Object>} Updated staff object
 */
const updateStaff = async (id, staffData) => {
  // First check if the staff member exists
  const existingStaff = await getStaffById(id);
  if (!existingStaff) {
    return null;
  }

  // Build dynamic update lists with PostgreSQL-style placeholders
  const fieldsAllowed = [
    'first_name',
    'last_name',
    'address',
    'suburb',
    'state',
    'postcode',
    'phone',
    'email',
    'position',
    'contracted_hours',
    'base_pay_rate',
    'active'
  ];

  const setFragments = [];
  const values = [];
  let paramIdx = 1;

  for (const [key, value] of Object.entries(staffData)) {
    // map frontend keys -> DB columns where necessary
    let column = key;
    // accept legacy keys coming from older frontend builds
    if (key === 'contact_phone') column = 'phone';
    if (key === 'contact_email') column = 'email';
    if (key === 'role') column = 'position';           // legacy -> new
    if (key === 'pay_rate' || key === 'hourly_rate') column = 'base_pay_rate'; // legacy -> new

    if (fieldsAllowed.includes(column)) {
      setFragments.push(`${column} = $${paramIdx++}`);
      values.push(value);
    }
  }

  if (setFragments.length === 0) return existingStaff; // nothing to update

  // updated_at timestamp
  setFragments.push(`updated_at = CURRENT_TIMESTAMP`);

  // add staff id for WHERE clause
  values.push(id);

  const query = `
    UPDATE staff
    SET ${setFragments.join(', ')}
    WHERE id = $${paramIdx}
    RETURNING *`;

  try {
    const result = await pool.query(query, values);
    return result.rows[0] || null;
  } catch (err) {
    console.error('Error updating staff:', err.message);
    throw err;
  }
};

/**
 * Delete a staff member
 * @param {string} id - Staff ID
 * @returns {Promise<boolean>} True if deleted, false if not found
 */
const deleteStaff = async (id) => {
  try {
    const result = await pool.query('DELETE FROM staff WHERE id = $1 RETURNING id', [id]);
    return result.rowCount > 0;
  } catch (err) {
    console.error('Error deleting staff:', err.message);
    throw err;
  }
};

/**
 * Get all staff members with SCHADS level information
 * @returns {Promise<Array>} Array of staff objects with SCHADS data
 */
const getStaffWithSchads = async () => {
  try {
    // For now, return basic staff data with placeholder SCHADS info
    // In a full implementation, this would join with a SCHADS rates table
    const result = await pool.query(`
      SELECT 
        s.*,
        'Level 5' as schads_level,
        28.50 as hourly_rate,
        'Support Worker' as role
      FROM staff s
      WHERE s.active = true
      ORDER BY s.last_name, s.first_name
    `);
    
    return result.rows;
  } catch (err) {
    console.error('Error fetching staff with SCHADS:', err.message);
    throw err;
  }
};

/**
 * TEMPORARY stub so frontend widget doesn't crash.
 * Once `staff_assignments` table exists, implement real logic.
 */
const getStaffHours = async (from, to) => {
  return []; // return empty list so React component renders nothing
};

module.exports = {
  getAllStaff,
  getStaffById,
  getStaffWithSchads,
  createStaff,
  updateStaff,
  deleteStaff,
  getStaffHours
};
