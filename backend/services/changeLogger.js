/**
 * backend/services/changeLogger.js
 * 
 * Comprehensive change logging service that tracks all participant and program changes
 * throughout the system. Provides functions for logging different types of changes
 * and retrieving change history for different views.
 */

const { pool } = require('../database');
const { formatDateForDb } = require('../utils/dateUtils');
const logger = require('../utils/logger');

// Constants for change types
const CHANGE_TYPE = {
  // Program-related changes
  PROGRAM_JOIN: 'PROGRAM_JOIN',           // Participant permanently joining a recurring program
  PROGRAM_LEAVE: 'PROGRAM_LEAVE',         // Participant permanently leaving a recurring program
  PROGRAM_CANCEL: 'PROGRAM_CANCEL',       // Participant cancelling attendance for a specific date
  PROGRAM_RESCHEDULE: 'PROGRAM_RESCHEDULE', // Program rescheduled to different time/date
  
  // Staff-related changes
  STAFF_ASSIGN: 'STAFF_ASSIGN',           // Staff assigned to program/instance
  STAFF_UNASSIGN: 'STAFF_UNASSIGN',       // Staff removed from program/instance
  STAFF_REPLACE: 'STAFF_REPLACE',         // Staff replaced with another staff
  
  // Vehicle-related changes
  VEHICLE_ASSIGN: 'VEHICLE_ASSIGN',       // Vehicle assigned to program/instance
  VEHICLE_UNASSIGN: 'VEHICLE_UNASSIGN',   // Vehicle removed from program/instance
  
  // Participant-related changes
  PARTICIPANT_ADD: 'PARTICIPANT_ADD',     // Participant added to specific instance (not recurring)
  PARTICIPANT_REMOVE: 'PARTICIPANT_REMOVE', // Participant removed from specific instance (not recurring)
  
  // Billing-related changes
  BILLING_CODE_CHANGE: 'BILLING_CODE_CHANGE', // Billing code changed
  BILLING_HOURS_CHANGE: 'BILLING_HOURS_CHANGE', // Billing hours changed
  
  // Other changes
  VENUE_CHANGE: 'VENUE_CHANGE',           // Program venue changed
  TIME_CHANGE: 'TIME_CHANGE',             // Program time changed
  NOTE_CHANGE: 'NOTE_CHANGE'              // Note added or changed
};

// Constants for change categories
const CHANGE_CATEGORY = {
  PERMANENT: 'PERMANENT',   // Ongoing changes to regular schedule
  TEMPORARY: 'TEMPORARY',   // One-off changes, cancellations
  BILLING_IMPACT: 'BILLING_IMPACT' // Changes that affect billing
};

// Constants for billing impact status
const BILLING_STATUS = {
  BILLED: 'BILLED',         // Change resulted in billing
  NOT_BILLED: 'NOT_BILLED', // Change did not result in billing
  PENDING: 'PENDING',       // Billing status pending
  NA: 'NA'                  // Not applicable
};

// Constants for change sources
const CHANGE_SOURCE = {
  MANUAL_ENTRY: 'MANUAL_ENTRY',     // Manually entered by user
  LOOM_AUTO: 'LOOM_AUTO',           // Automatically generated by loom
  BULK_IMPORT: 'BULK_IMPORT',       // Imported from external system
  API: 'API',                       // Changed via API
  SYSTEM: 'SYSTEM'                  // System-generated change
};

/**
 * Log a change to the system
 * @param {Object} changeData - Data about the change
 * @returns {Promise<Object>} - The logged change
 */
const logChange = async (changeData) => {
  try {
    // Validate required fields
    const requiredFields = ['change_type', 'change_category', 'changed_by', 'reason'];
    for (const field of requiredFields) {
      if (!changeData[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    // Set default values
    const now = new Date();
    const change = {
      change_date: now,
      effective_date: changeData.effective_date || now,
      change_type: changeData.change_type,
      change_category: changeData.change_category,
      changed_by: changeData.changed_by,
      reason: changeData.reason,
      source: changeData.source || CHANGE_SOURCE.MANUAL_ENTRY,
      billing_impact: changeData.billing_impact || false,
      billing_status: changeData.billing_status || BILLING_STATUS.NA,
      program_id: changeData.program_id || null,
      program_instance_id: changeData.program_instance_id || null,
      participant_id: changeData.participant_id || null,
      staff_id: changeData.staff_id || null,
      vehicle_id: changeData.vehicle_id || null,
      venue_id: changeData.venue_id || null,
      details: JSON.stringify(changeData.details || {}),
      related_change_id: changeData.related_change_id || null
    };

    // Insert into database
    const query = `
      INSERT INTO change_log (
        change_date, effective_date, change_type, change_category, 
        changed_by, reason, source, billing_impact, billing_status,
        program_id, program_instance_id, participant_id, staff_id, 
        vehicle_id, venue_id, details, related_change_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
      ) RETURNING id, change_date, change_type, change_category
    `;

    const values = [
      change.change_date, change.effective_date, change.change_type, change.change_category,
      change.changed_by, change.reason, change.source, change.billing_impact, change.billing_status,
      change.program_id, change.program_instance_id, change.participant_id, change.staff_id,
      change.vehicle_id, change.venue_id, change.details, change.related_change_id
    ];

    const { rows } = await pool.query(query, values);
    
    // Return the logged change with ID
    return {
      success: true,
      change_id: rows[0].id,
      ...change
    };
  } catch (error) {
    logger.error('Error logging change', { error, changeData });
    return {
      success: false,
      error: error.message,
      changeData
    };
  }
};

/**
 * Log a participant joining a program permanently
 * @param {String} participantId - ID of the participant
 * @param {String} programId - ID of the program
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logProgramJoin = async (
  participantId, 
  programId, 
  effectiveDate, 
  changedBy, 
  reason, 
  additionalDetails = {}
) => {
  const details = {
    program_name: additionalDetails.program_name,
    days_of_week: additionalDetails.days_of_week,
    start_time: additionalDetails.start_time,
    end_time: additionalDetails.end_time,
    venue_name: additionalDetails.venue_name,
    billing_codes: additionalDetails.billing_codes,
    ...additionalDetails
  };

  return await logChange({
    change_type: CHANGE_TYPE.PROGRAM_JOIN,
    change_category: CHANGE_CATEGORY.PERMANENT,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    participant_id: participantId,
    program_id: programId,
    billing_impact: additionalDetails.billing_codes ? true : false,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a participant leaving a program permanently
 * @param {String} participantId - ID of the participant
 * @param {String} programId - ID of the program
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logProgramLeave = async (
  participantId, 
  programId, 
  effectiveDate, 
  changedBy, 
  reason, 
  additionalDetails = {}
) => {
  const details = {
    program_name: additionalDetails.program_name,
    days_of_week: additionalDetails.days_of_week,
    ...additionalDetails
  };

  return await logChange({
    change_type: CHANGE_TYPE.PROGRAM_LEAVE,
    change_category: CHANGE_CATEGORY.PERMANENT,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    participant_id: participantId,
    program_id: programId,
    billing_impact: true,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a participant cancelling attendance for a specific date
 * @param {String} participantId - ID of the participant
 * @param {String} programInstanceId - ID of the program instance
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Boolean} isBilled - Whether the cancellation is billed
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logProgramCancel = async (
  participantId, 
  programInstanceId, 
  effectiveDate, 
  changedBy, 
  reason, 
  isBilled = false,
  additionalDetails = {}
) => {
  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date, start_time, end_time
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  const details = {
    program_name: programDetails.program_name,
    date: programDetails.date,
    start_time: programDetails.start_time,
    end_time: programDetails.end_time,
    is_short_notice: additionalDetails.is_short_notice || false,
    cancellation_hours: additionalDetails.cancellation_hours,
    ...additionalDetails
  };

  return await logChange({
    change_type: CHANGE_TYPE.PROGRAM_CANCEL,
    change_category: CHANGE_CATEGORY.TEMPORARY,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    participant_id: participantId,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    billing_impact: true,
    billing_status: isBilled ? BILLING_STATUS.BILLED : BILLING_STATUS.NOT_BILLED,
    details
  });
};

/**
 * Log a program being rescheduled
 * @param {String} programInstanceId - ID of the program instance
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} changes - Changes to the program (new_date, new_start_time, new_end_time, new_venue_id)
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logProgramReschedule = async (
  programInstanceId, 
  effectiveDate, 
  changedBy, 
  reason, 
  changes = {},
  additionalDetails = {}
) => {
  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date, start_time, end_time, venue_id
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  const details = {
    program_name: programDetails.program_name,
    original_date: programDetails.date,
    original_start_time: programDetails.start_time,
    original_end_time: programDetails.end_time,
    original_venue_id: programDetails.venue_id,
    new_date: changes.new_date || programDetails.date,
    new_start_time: changes.new_start_time || programDetails.start_time,
    new_end_time: changes.new_end_time || programDetails.end_time,
    new_venue_id: changes.new_venue_id || programDetails.venue_id,
    ...additionalDetails
  };

  return await logChange({
    change_type: CHANGE_TYPE.PROGRAM_RESCHEDULE,
    change_category: CHANGE_CATEGORY.TEMPORARY,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    venue_id: changes.new_venue_id,
    billing_impact: additionalDetails.billing_impact || false,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a staff assignment change
 * @param {String} staffId - ID of the staff
 * @param {String} programInstanceId - ID of the program instance
 * @param {String} changeType - Type of staff change (ASSIGN, UNASSIGN, REPLACE)
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logStaffChange = async (
  staffId, 
  programInstanceId, 
  changeType, 
  effectiveDate, 
  changedBy, 
  reason, 
  additionalDetails = {}
) => {
  // Validate change type
  if (!Object.values(CHANGE_TYPE).includes(changeType)) {
    if (changeType === 'ASSIGN') changeType = CHANGE_TYPE.STAFF_ASSIGN;
    else if (changeType === 'UNASSIGN') changeType = CHANGE_TYPE.STAFF_UNASSIGN;
    else if (changeType === 'REPLACE') changeType = CHANGE_TYPE.STAFF_REPLACE;
    else throw new Error(`Invalid staff change type: ${changeType}`);
  }

  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date, start_time, end_time
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  // Get staff details
  let staffDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT first_name, last_name, role, schads_level
       FROM staff
       WHERE id = $1`,
      [staffId]
    );
    if (rows.length > 0) {
      staffDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching staff details', { error, staffId });
  }

  const details = {
    program_name: programDetails.program_name,
    date: programDetails.date,
    start_time: programDetails.start_time,
    end_time: programDetails.end_time,
    staff_name: staffDetails.first_name && staffDetails.last_name ? 
      `${staffDetails.first_name} ${staffDetails.last_name}` : 'Unknown',
    staff_role: staffDetails.role,
    schads_level: staffDetails.schads_level,
    replacement_staff_id: additionalDetails.replacement_staff_id,
    replacement_staff_name: additionalDetails.replacement_staff_name,
    ...additionalDetails
  };

  return await logChange({
    change_type: changeType,
    change_category: CHANGE_CATEGORY.TEMPORARY,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    staff_id: staffId,
    billing_impact: false,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a vehicle assignment change
 * @param {String} vehicleId - ID of the vehicle
 * @param {String} programInstanceId - ID of the program instance
 * @param {String} changeType - Type of vehicle change (ASSIGN, UNASSIGN)
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logVehicleChange = async (
  vehicleId, 
  programInstanceId, 
  changeType, 
  effectiveDate, 
  changedBy, 
  reason, 
  additionalDetails = {}
) => {
  // Validate change type
  if (!Object.values(CHANGE_TYPE).includes(changeType)) {
    if (changeType === 'ASSIGN') changeType = CHANGE_TYPE.VEHICLE_ASSIGN;
    else if (changeType === 'UNASSIGN') changeType = CHANGE_TYPE.VEHICLE_UNASSIGN;
    else throw new Error(`Invalid vehicle change type: ${changeType}`);
  }

  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date, start_time, end_time
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  // Get vehicle details
  let vehicleDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT name, registration, capacity, wheelchair_capacity
       FROM vehicles
       WHERE id = $1`,
      [vehicleId]
    );
    if (rows.length > 0) {
      vehicleDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching vehicle details', { error, vehicleId });
  }

  const details = {
    program_name: programDetails.program_name,
    date: programDetails.date,
    start_time: programDetails.start_time,
    end_time: programDetails.end_time,
    vehicle_name: vehicleDetails.name,
    registration: vehicleDetails.registration,
    capacity: vehicleDetails.capacity,
    wheelchair_capacity: vehicleDetails.wheelchair_capacity,
    run_type: additionalDetails.run_type, // 'PICKUP' or 'DROPOFF'
    ...additionalDetails
  };

  return await logChange({
    change_type: changeType,
    change_category: CHANGE_CATEGORY.TEMPORARY,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    vehicle_id: vehicleId,
    billing_impact: false,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a participant being added or removed from a specific instance
 * @param {String} participantId - ID of the participant
 * @param {String} programInstanceId - ID of the program instance
 * @param {String} changeType - Type of participant change (ADD, REMOVE)
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} additionalDetails - Additional details about the change
 * @returns {Promise<Object>} - The logged change
 */
const logParticipantChange = async (
  participantId, 
  programInstanceId, 
  changeType, 
  effectiveDate, 
  changedBy, 
  reason, 
  additionalDetails = {}
) => {
  // Validate change type
  if (!Object.values(CHANGE_TYPE).includes(changeType)) {
    if (changeType === 'ADD') changeType = CHANGE_TYPE.PARTICIPANT_ADD;
    else if (changeType === 'REMOVE') changeType = CHANGE_TYPE.PARTICIPANT_REMOVE;
    else throw new Error(`Invalid participant change type: ${changeType}`);
  }

  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date, start_time, end_time
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  // Get participant details
  let participantDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT first_name, last_name, supervision_multiplier
       FROM participants
       WHERE id = $1`,
      [participantId]
    );
    if (rows.length > 0) {
      participantDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching participant details', { error, participantId });
  }

  const details = {
    program_name: programDetails.program_name,
    date: programDetails.date,
    start_time: programDetails.start_time,
    end_time: programDetails.end_time,
    participant_name: participantDetails.first_name && participantDetails.last_name ? 
      `${participantDetails.first_name} ${participantDetails.last_name}` : 'Unknown',
    supervision_multiplier: participantDetails.supervision_multiplier,
    billing_codes: additionalDetails.billing_codes,
    ...additionalDetails
  };

  return await logChange({
    change_type: changeType,
    change_category: CHANGE_CATEGORY.TEMPORARY,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    participant_id: participantId,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    billing_impact: additionalDetails.billing_codes ? true : false,
    billing_status: BILLING_STATUS.NA,
    details
  });
};

/**
 * Log a billing code change
 * @param {String} participantId - ID of the participant
 * @param {String} programInstanceId - ID of the program instance
 * @param {Date} effectiveDate - Date when the change takes effect
 * @param {String} changedBy - ID of the user making the change
 * @param {String} reason - Reason for the change
 * @param {Object} billingChanges - Changes to billing (old_codes, new_codes)
 * @returns {Promise<Object>} - The logged change
 */
const logBillingCodeChange = async (
  participantId, 
  programInstanceId, 
  effectiveDate, 
  changedBy, 
  reason, 
  billingChanges = {}
) => {
  // Get program instance details
  let programDetails = {};
  try {
    const { rows } = await pool.query(
      `SELECT program_id, program_name, date
       FROM tgl_loom_instances
       WHERE id = $1`,
      [programInstanceId]
    );
    if (rows.length > 0) {
      programDetails = rows[0];
    }
  } catch (error) {
    logger.error('Error fetching program instance details', { error, programInstanceId });
  }

  const details = {
    program_name: programDetails.program_name,
    date: programDetails.date,
    old_billing_codes: billingChanges.old_codes,
    new_billing_codes: billingChanges.new_codes
  };

  return await logChange({
    change_type: CHANGE_TYPE.BILLING_CODE_CHANGE,
    change_category: CHANGE_CATEGORY.BILLING_IMPACT,
    changed_by: changedBy,
    reason,
    effective_date: effectiveDate,
    participant_id: participantId,
    program_id: programDetails.program_id,
    program_instance_id: programInstanceId,
    billing_impact: true,
    billing_status: BILLING_STATUS.PENDING,
    details
  });
};

/**
 * Get change history for a participant
 * @param {String} participantId - ID of the participant
 * @param {Object} options - Query options (limit, offset, start_date, end_date, change_types)
 * @returns {Promise<Array>} - Array of changes
 */
const getParticipantChangeHistory = async (participantId, options = {}) => {
  try {
    const {
      limit = 100,
      offset = 0,
      start_date,
      end_date,
      change_types = []
    } = options;

    // Build query conditions
    const conditions = ['participant_id = $1'];
    const params = [participantId];
    let paramIndex = 2;

    if (start_date) {
      conditions.push(`effective_date >= $${paramIndex++}`);
      params.push(start_date);
    }

    if (end_date) {
      conditions.push(`effective_date <= $${paramIndex++}`);
      params.push(end_date);
    }

    if (change_types.length > 0) {
      conditions.push(`change_type IN (${change_types.map((_, i) => `$${paramIndex + i}`).join(', ')})`);
      params.push(...change_types);
      paramIndex += change_types.length;
    }

    // Build the query
    const query = `
      SELECT 
        cl.id,
        cl.change_date,
        cl.effective_date,
        cl.change_type,
        cl.change_category,
        cl.changed_by,
        cl.reason,
        cl.source,
        cl.billing_impact,
        cl.billing_status,
        cl.program_id,
        cl.program_instance_id,
        cl.participant_id,
        cl.staff_id,
        cl.vehicle_id,
        cl.venue_id,
        cl.details,
        cl.related_change_id,
        u.first_name || ' ' || u.last_name AS changed_by_name
      FROM 
        change_log cl
      LEFT JOIN 
        users u ON cl.changed_by = u.id
      WHERE 
        ${conditions.join(' AND ')}
      ORDER BY 
        cl.effective_date DESC, cl.change_date DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;

    params.push(limit, offset);

    const { rows } = await pool.query(query, params);

    // Parse details JSON
    return rows.map(row => ({
      ...row,
      details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details
    }));
  } catch (error) {
    logger.error('Error fetching participant change history', { error, participantId });
    return [];
  }
};

/**
 * Get changes for a specific day
 * @param {Date} date - The date to get changes for
 * @param {Object} options - Query options (limit, offset, change_types, change_categories)
 * @returns {Promise<Array>} - Array of changes
 */
const getDailyChanges = async (date, options = {}) => {
  try {
    const {
      limit = 100,
      offset = 0,
      change_types = [],
      change_categories = []
    } = options;

    // Format date for DB
    const dateStr = formatDateForDb(date);

    // Build query conditions
    const conditions = ['effective_date::date = $1'];
    const params = [dateStr];
    let paramIndex = 2;

    if (change_types.length > 0) {
      conditions.push(`change_type IN (${change_types.map((_, i) => `$${paramIndex + i}`).join(', ')})`);
      params.push(...change_types);
      paramIndex += change_types.length;
    }

    if (change_categories.length > 0) {
      conditions.push(`change_category IN (${change_categories.map((_, i) => `$${paramIndex + i}`).join(', ')})`);
      params.push(...change_categories);
      paramIndex += change_categories.length;
    }

    // Build the query
    const query = `
      SELECT 
        cl.id,
        cl.change_date,
        cl.effective_date,
        cl.change_type,
        cl.change_category,
        cl.changed_by,
        cl.reason,
        cl.source,
        cl.billing_impact,
        cl.billing_status,
        cl.program_id,
        cl.program_instance_id,
        cl.participant_id,
        cl.staff_id,
        cl.vehicle_id,
        cl.venue_id,
        cl.details,
        cl.related_change_id,
        u.first_name || ' ' || u.last_name AS changed_by_name,
        p.first_name || ' ' || p.last_name AS participant_name,
        s.first_name || ' ' || s.last_name AS staff_name,
        v.name AS vehicle_name,
        pr.name AS program_name
      FROM 
        change_log cl
      LEFT JOIN 
        users u ON cl.changed_by = u.id
      LEFT JOIN
        participants p ON cl.participant_id = p.id
      LEFT JOIN
        staff s ON cl.staff_id = s.id
      LEFT JOIN
        vehicles v ON cl.vehicle_id = v.id
      LEFT JOIN
        programs pr ON cl.program_id = pr.id
      WHERE 
        ${conditions.join(' AND ')}
      ORDER BY 
        cl.change_date DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;

    params.push(limit, offset);

    const { rows } = await pool.query(query, params);

    // Parse details JSON
    return rows.map(row => ({
      ...row,
      details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details
    }));
  } catch (error) {
    logger.error('Error fetching daily changes', { error, date });
    return [];
  }
};

/**
 * Get changes for a specific program instance
 * @param {String} programInstanceId - ID of the program instance
 * @param {Object} options - Query options (limit, offset, change_types)
 * @returns {Promise<Array>} - Array of changes
 */
const getProgramInstanceChanges = async (programInstanceId, options = {}) => {
  try {
    const {
      limit = 100,
      offset = 0,
      change_types = []
    } = options;

    // Build query conditions
    const conditions = ['program_instance_id = $1'];
    const params = [programInstanceId];
    let paramIndex = 2;

    if (change_types.length > 0) {
      conditions.push(`change_type IN (${change_types.map((_, i) => `$${paramIndex + i}`).join(', ')})`);
      params.push(...change_types);
      paramIndex += change_types.length;
    }

    // Build the query
    const query = `
      SELECT 
        cl.id,
        cl.change_date,
        cl.effective_date,
        cl.change_type,
        cl.change_category,
        cl.changed_by,
        cl.reason,
        cl.source,
        cl.billing_impact,
        cl.billing_status,
        cl.program_id,
        cl.program_instance_id,
        cl.participant_id,
        cl.staff_id,
        cl.vehicle_id,
        cl.venue_id,
        cl.details,
        cl.related_change_id,
        u.first_name || ' ' || u.last_name AS changed_by_name,
        p.first_name || ' ' || p.last_name AS participant_name,
        s.first_name || ' ' || s.last_name AS staff_name
      FROM 
        change_log cl
      LEFT JOIN 
        users u ON cl.changed_by = u.id
      LEFT JOIN
        participants p ON cl.participant_id = p.id
      LEFT JOIN
        staff s ON cl.staff_id = s.id
      WHERE 
        ${conditions.join(' AND ')}
      ORDER BY 
        cl.change_date DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;

    params.push(limit, offset);

    const { rows } = await pool.query(query, params);

    // Parse details JSON
    return rows.map(row => ({
      ...row,
      details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details
    }));
  } catch (error) {
    logger.error('Error fetching program instance changes', { error, programInstanceId });
    return [];
  }
};

/**
 * Get changes with billing impact
 * @param {Object} options - Query options (start_date, end_date, billing_status, limit, offset)
 * @returns {Promise<Array>} - Array of changes
 */
const getBillingImpactChanges = async (options = {}) => {
  try {
    const {
      start_date,
      end_date,
      billing_status,
      limit = 100,
      offset = 0
    } = options;

    // Build query conditions
    const conditions = ['billing_impact = true'];
    const params = [];
    let paramIndex = 1;

    if (start_date) {
      conditions.push(`effective_date >= $${paramIndex++}`);
      params.push(start_date);
    }

    if (end_date) {
      conditions.push(`effective_date <= $${paramIndex++}`);
      params.push(end_date);
    }

    if (billing_status) {
      conditions.push(`billing_status = $${paramIndex++}`);
      params.push(billing_status);
    }

    // Build the query
    const query = `
      SELECT 
        cl.id,
        cl.change_date,
        cl.effective_date,
        cl.change_type,
        cl.change_category,
        cl.changed_by,
        cl.reason,
        cl.source,
        cl.billing_impact,
        cl.billing_status,
        cl.program_id,
        cl.program_instance_id,
        cl.participant_id,
        cl.staff_id,
        cl.details,
        cl.related_change_id,
        p.first_name || ' ' || p.last_name AS participant_name,
        pr.name AS program_name
      FROM 
        change_log cl
      LEFT JOIN
        participants p ON cl.participant_id = p.id
      LEFT JOIN
        programs pr ON cl.program_id = pr.id
      WHERE 
        ${conditions.join(' AND ')}
      ORDER BY 
        cl.effective_date DESC, cl.change_date DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `;

    params.push(limit, offset);

    const { rows } = await pool.query(query, params);

    // Parse details JSON
    return rows.map(row => ({
      ...row,
      details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details
    }));
  } catch (error) {
    logger.error('Error fetching billing impact changes', { error, options });
    return [];
  }
};

/**
 * Update billing status for a change
 * @param {String} changeId - ID of the change
 * @param {String} billingStatus - New billing status
 * @param {String} updatedBy - ID of the user updating the status
 * @param {String} reason - Reason for the update
 * @returns {Promise<Object>} - Result of the update
 */
const updateBillingStatus = async (changeId, billingStatus, updatedBy, reason) => {
  try {
    // Validate billing status
    if (!Object.values(BILLING_STATUS).includes(billingStatus)) {
      throw new Error(`Invalid billing status: ${billingStatus}`);
    }

    // Update the billing status
    const query = `
      UPDATE change_log
      SET 
        billing_status = $1,
        details = details || jsonb_build_object(
          'billing_status_updated_by', $2,
          'billing_status_update_reason', $3,
          'billing_status_update_date', $4
        )
      WHERE 
        id = $5
      RETURNING id, change_type, billing_status
    `;

    const params = [
      billingStatus,
      updatedBy,
      reason,
      new Date(),
      changeId
    ];

    const { rows } = await pool.query(query, params);

    if (rows.length === 0) {
      return {
        success: false,
        message: 'Change not found'
      };
    }

    return {
      success: true,
      message: 'Billing status updated successfully',
      change: rows[0]
    };
  } catch (error) {
    logger.error('Error updating billing status', { error, changeId, billingStatus });
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Format a change for display in the UI
 * @param {Object} change - The change to format
 * @returns {Object} - Formatted change
 */
const formatChangeForDisplay = (change) => {
  try {
    const details = typeof change.details === 'string' ? JSON.parse(change.details) : change.details;
    
    // Base formatted change
    const formatted = {
      id: change.id,
      date: change.effective_date,
      changeDate: change.change_date,
      type: change.change_type,
      category: change.change_category,
      changedBy: change.changed_by_name || change.changed_by,
      reason: change.reason,
      billingImpact: change.billing_impact,
      billingStatus: change.billing_status
    };

    // Add specific details based on change type
    switch (change.change_type) {
      case CHANGE_TYPE.PROGRAM_JOIN:
        formatted.message = `${change.participant_name || 'Participant'} joined ${details.program_name || 'program'}`;
        formatted.details = `Starting from ${new Date(change.effective_date).toLocaleDateString()}`;
        if (details.days_of_week) {
          formatted.details += ` on ${details.days_of_week}`;
        }
        if (details.start_time && details.end_time) {
          formatted.details += ` (${details.start_time.substring(0, 5)} - ${details.end_time.substring(0, 5)})`;
        }
        break;

      case CHANGE_TYPE.PROGRAM_LEAVE:
        formatted.message = `${change.participant_name || 'Participant'} left ${details.program_name || 'program'}`;
        formatted.details = `Effective from ${new Date(change.effective_date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.PROGRAM_CANCEL:
        formatted.message = `${change.participant_name || 'Participant'} cancelled ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        if (details.is_short_notice) {
          formatted.details += ` (Short notice: ${details.cancellation_hours} hours)`;
        }
        formatted.billingTag = change.billing_status === BILLING_STATUS.BILLED ? 'BILLED' : 'NOT BILLED';
        break;

      case CHANGE_TYPE.PROGRAM_RESCHEDULE:
        formatted.message = `${details.program_name || 'Program'} rescheduled`;
        formatted.details = `From ${new Date(details.original_date).toLocaleDateString()} to ${new Date(details.new_date).toLocaleDateString()}`;
        if (details.original_start_time !== details.new_start_time || details.original_end_time !== details.new_end_time) {
          formatted.details += `, time changed from ${details.original_start_time.substring(0, 5)}-${details.original_end_time.substring(0, 5)} to ${details.new_start_time.substring(0, 5)}-${details.new_end_time.substring(0, 5)}`;
        }
        break;

      case CHANGE_TYPE.STAFF_ASSIGN:
        formatted.message = `${details.staff_name || 'Staff'} assigned to ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()} (${details.staff_role || 'Staff'})`;
        break;

      case CHANGE_TYPE.STAFF_UNASSIGN:
        formatted.message = `${details.staff_name || 'Staff'} removed from ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.STAFF_REPLACE:
        formatted.message = `${details.staff_name || 'Staff'} replaced with ${details.replacement_staff_name || 'new staff'}`;
        formatted.details = `For ${details.program_name || 'program'} on ${new Date(details.date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.VEHICLE_ASSIGN:
        formatted.message = `${details.vehicle_name || 'Vehicle'} assigned to ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        if (details.run_type) {
          formatted.details += ` (${details.run_type})`;
        }
        break;

      case CHANGE_TYPE.VEHICLE_UNASSIGN:
        formatted.message = `${details.vehicle_name || 'Vehicle'} removed from ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.PARTICIPANT_ADD:
        formatted.message = `${change.participant_name || 'Participant'} added to ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.PARTICIPANT_REMOVE:
        formatted.message = `${change.participant_name || 'Participant'} removed from ${details.program_name || 'program'}`;
        formatted.details = `For ${new Date(details.date).toLocaleDateString()}`;
        break;

      case CHANGE_TYPE.BILLING_CODE_CHANGE:
        formatted.message = `Billing codes changed for ${change.participant_name || 'participant'}`;
        formatted.details = `In ${details.program_name || 'program'} on ${new Date(details.date).toLocaleDateString()}`;
        formatted.billingTag = 'BILLING CHANGED';
        break;

      default:
        formatted.message = `${change.change_type.replace(/_/g, ' ')}`;
        formatted.details = `Effective ${new Date(change.effective_date).toLocaleDateString()}`;
    }

    return formatted;
  } catch (error) {
    logger.error('Error formatting change for display', { error, change });
    return {
      id: change.id,
      date: change.effective_date,
      message: 'Error formatting change',
      details: 'Unable to display details',
      type: change.change_type,
      category: change.change_category
    };
  }
};

module.exports = {
  // Constants
  CHANGE_TYPE,
  CHANGE_CATEGORY,
  BILLING_STATUS,
  CHANGE_SOURCE,
  
  // Core logging functions
  logChange,
  
  // Specific logging functions
  logProgramJoin,
  logProgramLeave,
  logProgramCancel,
  logProgramReschedule,
  logStaffChange,
  logVehicleChange,
  logParticipantChange,
  logBillingCodeChange,
  
  // Retrieval functions
  getParticipantChangeHistory,
  getDailyChanges,
  getProgramInstanceChanges,
  getBillingImpactChanges,
  
  // Utility functions
  updateBillingStatus,
  formatChangeForDisplay
};
